use std::fmt;
use std::rc::Rc;

use ic_exports::candid;
use ic_exports::candid::types::internal::TypeContainer;
use ic_exports::candid::types::{Type, TypeInner};

pub struct Idl {
    pub env: TypeContainer,
    pub actor: Type,
}

impl fmt::Display for Idl {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Idl: {}", self.actor)
    }
}

impl Idl {
    pub fn new(env: TypeContainer, actor: Type) -> Self {
        Self { env, actor }
    }

    pub fn merge(&mut self, other: &Self) {
        self.env = candid::types::internal::TypeContainer {
            env: self.env.env.merge(&other.env.env).unwrap().clone(),
        };

        match (self.actor.0.as_ref(), other.actor.0.as_ref()) {
            (TypeInner::Class(ref class, left), TypeInner::Service(ref right)) => {
                match left.0.as_ref() {
                    TypeInner::Service(left) => {
                        let mut left = left.clone();
                        left.extend(right.clone());
                        self.actor = Type(Rc::new(TypeInner::Class(
                            class.to_vec(),
                            Type(Rc::new(TypeInner::Service(left))),
                        )));
                    }
                    _ => {
                        panic!("type {left:#?} is not a service")
                    }
                }
            }
            (TypeInner::Service(left), TypeInner::Class(ref class, right)) => {
                match right.0.as_ref() {
                    TypeInner::Service(right) => {
                        let mut left = left.clone();
                        left.extend(right.clone());
                        self.actor = Type(Rc::new(TypeInner::Class(
                            class.to_vec(),
                            Type(Rc::new(TypeInner::Service(left))),
                        )));
                    }
                    _ => {
                        panic!("type {right:#?} is not a service")
                    }
                }
            }
            (TypeInner::Service(left), TypeInner::Service(right)) => {
                let mut left = left.clone();
                left.extend(right.clone());
                self.actor = Type(Rc::new(TypeInner::Service(left)));
            }
            (l @ TypeInner::Class(_, _), r @ TypeInner::Class(_, _)) => {
                panic!("cannot merge two candid classes: self:\n{l:#?}\nother:\n{r:#?}")
            }
            (l, r) => {
                panic!(
                    "wrong candid types were generated by the macro: self:\n{l:#?}\nother:\n{r:#?}"
                )
            }
        }
    }
}
